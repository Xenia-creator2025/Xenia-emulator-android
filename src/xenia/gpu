                              getElsePhiParent());}SpirvBuilder::SwitchBuilder::SwitchBuilder(spv::Id selector,                                           unsigned int selection_control,                                           SpirvBuilder& builder)    : builder_(builder),      selector_(selector),      selection_control_(selection_control),      function_(builder.getBuildPoint()->getParent()),      header_block_(builder.getBuildPoint()),      default_phi_parent_(builder.getBuildPoint()->getId()) {  merge_block_ = new spv::Block(builder_.getUniqueId(), function_);}void SpirvBuilder::SwitchBuilder::makeBeginDefault() {  assert_null(default_block_);  endSegment();  default_block_ = new spv::Block(builder_.getUniqueId(), function_);  function_.addBlock(default_block_);  default_block_->addPredecessor(header_block_);  builder_.setBuildPoint(default_block_);  current_branch_ = Branch::kDefault;}void SpirvBuilder::SwitchBuilder::makeBeginCase(unsigned int literal) {  endSegment();  auto case_block = new spv::Block(builder_.getUniqueId(), function_);  function_.addBlock(case_block);  cases_.emplace_back(literal, case_block->getId());  case_block->addPredecessor(header_block_);  builder_.setBuildPoint(case_block);  current_branch_ = Branch::kCase;}void SpirvBuilder::SwitchBuilder::addCurrentCaseLiteral(unsigned int literal) {  assert_true(current_branch_ == Branch::kCase);  cases_.emplace_back(literal, cases_.back().second);}void SpirvBuilder::SwitchBuilder::makeEndSwitch() {  endSegment();  builder_.setBuildPoint(header_block_);  builder_.createSelectionMerge(merge_block_, selection_control_);  std::unique_ptr<spv::Instruction> switch_instruction =      std::make_unique<spv::Instruction>(spv::OpSwitch);  switch_instruction->addIdOperand(selector_);  if (default_block_) {    switch_instruction->addIdOperand(default_block_->getId());  } else {    switch_instruction->addIdOperand(merge_block_->getId());    merge_block_->addPredecessor(header_block_);  }  for (const std::pair<unsigned int, spv::Id>& case_pair : cases_) {    switch_instruction->addImmediateOperand(case_pair.first);    switch_instruction->addIdOperand(case_pair.second);  }  builder_.getBuildPoint()->addInstruction(std::move(switch_instruction));  function_.addBlock(merge_block_);  builder_.setBuildPoint(merge_block_);  current_branch_ = Branch::kMerge;}void SpirvBuilder::SwitchBuilder::endSegment() {  assert_true(current_branch_ == Branch::kSelection ||              current_branch_ == Branch::kDefault ||              current_branch_ == Branch::kCase);  if (current_branch_ == Branch::kSelection) {    return;  }  if (!builder_.getBuildPoint()->isTerminated()) {    builder_.createBranch(merge_block_);    if (current_branch_ == Branch::kDefault) {      default_phi_parent_ = builder_.getBuildPoint()->getId();    }  }  current_branch_ = Branch::kSelection;}}  // namespace gpu}  // namespace xe
‎src/xenia/gpu/spirv_builder.hCopy file name to clipboardexpand all lines: src/xenia/gpu/spirv_builder.h+47Original file line numberDiff line numberDiff line change@@ -10,7 +10,10 @@#ifndef XENIA_GPU_SPIRV_BUILDER_H_#define XENIA_GPU_SPIRV_BUILDER_H_#include <memory>#include <optional>#include <utility>#include <vector>#include "third_party/glslang/SPIRV/SpvBuilder.h"#include "xenia/base/assert.h"@@ -99,6 +102,50 @@ class SpirvBuilder : public spv::Builder {    Branch currentBranch = Branch::kThen;#endif  };  // Simpler and more flexible (such as multiple cases pointing to the same  // block) compared to makeSwitch.  class SwitchBuilder {   public:    SwitchBuilder(spv::Id selector, unsigned int selection_control,                  SpirvBuilder& builder);    ~SwitchBuilder() { assert_true(current_branch_ == Branch::kMerge); }    void makeBeginDefault();    void makeBeginCase(unsigned int literal);    void addCurrentCaseLiteral(unsigned int literal);    void makeEndSwitch();    // If there's no default block that branches to the merge block, the phi    // parent is the header block - this simplifies case-only usage.    spv::Id getDefaultPhiParent() const { return default_phi_parent_; }   private:    enum class Branch {      kSelection,      kDefault,      kCase,      kMerge,    };    void endSegment();    SpirvBuilder& builder_;    spv::Id selector_;    unsigned int selection_control_;    spv::Function& function_;    spv::Block* header_block_;    spv::Block* merge_block_;    spv::Block* default_block_ = nullptr;    std::vector<std::pair<unsigned int, spv::Id>> cases_;    spv::Id default_phi_parent_;    Branch current_branch_ = Branch::kSelection;  };};}  // namespace gpu
‎src/xenia/gpu/spirv_shader_translator.ccCopy file name to clipboardexpand all lines: src/xenia/gpu/spirv_shader_translator.cc+294-57 Load DiffLarge diffs are not rendered by default.
‎src/xenia/gpu/spirv_shader_translator.hCopy file name to clipboardexpand all lines: src/xenia/gpu/spirv_shader_translator.h+65-8Original file line numberDiff line numberDiff line change@@ -323,17 +323,28 @@ class SpirvShaderTranslator : public ShaderTranslator {    explicit Features(        const ui::vulkan::VulkanProvider::DeviceInfo& device_info);    explicit Features(bool all = false);    unsigned int spirv_version;    uint32_t max_storage_buffer_range;    bool full_draw_index_uint32;    bool vertex_pipeline_stores_and_atomics;    bool fragment_stores_and_atomics;    bool clip_distance;    bool cull_distance;    bool demote_to_helper_invocation;    bool fragment_shader_sample_interlock;    bool full_draw_index_uint32;    bool image_view_format_swizzle;    bool signed_zero_inf_nan_preserve_float32;    bool denorm_flush_to_zero_float32;    bool rounding_mode_rte_float32;    bool fragment_shader_sample_interlock;    bool demote_to_helper_invocation;  };  SpirvShaderTranslator(const Features& features,@@ -424,6 +435,8 @@ class SpirvShaderTranslator : public ShaderTranslator {  void ProcessLoopEndInstruction(      const ParsedLoopEndInstruction& instr) override;  void ProcessJumpInstruction(const ParsedJumpInstruction& instr) override;  void ProcessAllocInstruction(const ParsedAllocInstruction& instr,                               uint8_t export_eM) override;  void ProcessVertexFetchInstruction(      const ParsedVertexFetchInstruction& instr) override;@@ -470,6 +483,11 @@ class SpirvShaderTranslator : public ShaderTranslator {           Shader::IsHostVertexShaderTypeDomain(               GetSpirvShaderModification().vertex.host_vertex_shader_type);  }  bool IsSpirvComputeShader() const {    return is_vertex_shader() &&           GetSpirvShaderModification().vertex.host_vertex_shader_type ==               Shader::HostVertexShaderType::kMemExportCompute;  }  bool IsExecutionModeEarlyFragmentTests() const {    return is_pixel_shader() &&@@ -567,24 +585,48 @@ class SpirvShaderTranslator : public ShaderTranslator {  spv::Id ZeroIfAnyOperandIsZero(spv::Id value, spv::Id operand_0_abs,                                 spv::Id operand_1_abs);  // Conditionally discard the current fragment. Changes the build point.  void KillPixel(spv::Id condition);  void KillPixel(spv::Id condition,                 uint8_t memexport_eM_potentially_written_before);  // Return type is a xe::bit_count(result.GetUsedResultComponents())-component  // float vector or a single float, depending on whether it's a reduction  // instruction (check getTypeId of the result), or returns spv::NoResult if  // nothing to store.  spv::Id ProcessVectorAluOperation(const ParsedAluInstruction& instr,                                    bool& predicate_written);  spv::Id ProcessVectorAluOperation(      const ParsedAluInstruction& instr,      uint8_t memexport_eM_potentially_written_before, bool& predicate_written);  // Returns a float value to write to the previous scalar register and to the  // destination. If the return value is ps itself (in the retain_prev case),  // returns spv::NoResult (handled as a special case, so if it's retain_prev,  // but don't need to write to anywhere, no OpLoad(ps) will be done).  spv::Id ProcessScalarAluOperation(const ParsedAluInstruction& instr,                                    bool& predicate_written);  spv::Id ProcessScalarAluOperation(      const ParsedAluInstruction& instr,      uint8_t memexport_eM_potentially_written_before, bool& predicate_written);  // Perform endian swap of a uint scalar or vector.  spv::Id EndianSwap32Uint(spv::Id value, spv::Id endian);  // Perform endian swap of a uint4 vector.  spv::Id EndianSwap128Uint4(spv::Id value, spv::Id endian);  spv::Id LoadUint32FromSharedMemory(spv::Id address_dwords_int);  // If `replace_mask` is provided, the bits specified in the mask will be  // replaced with those from the value via OpAtomicAnd/Or.  // Bits of `value` not in `replace_mask` will be ignored.  void StoreUint32ToSharedMemory(spv::Id value, spv::Id address_dwords_int,                                 spv::Id replace_mask = spv::NoResult);  bool IsMemoryExportSupported() const {    if (is_pixel_shader()) {      return features_.fragment_stores_and_atomics;    }    return features_.vertex_pipeline_stores_and_atomics ||           IsSpirvComputeShader();  }  bool IsMemoryExportUsed() const {    return current_shader().memexport_eM_written() && IsMemoryExportSupported();  }  void ExportToMemory(uint8_t export_eM);  // The source may be a floating-point scalar or a vector.  spv::Id PWLGammaToLinear(spv::Id gamma, bool gamma_pre_saturated);@@ -872,6 +914,21 @@ class SpirvShaderTranslator : public ShaderTranslator {  spv::Id var_main_tfetch_gradients_v_;  // float4[register_count()].  spv::Id var_main_registers_;  // Memory export variables are created only when needed.  // float4.  spv::Id var_main_memexport_address_;  // Each is float4.  spv::Id var_main_memexport_data_[ucode::kMaxMemExportElementCount];  // Bit field of which eM# elements have been written so far by the invocation  // since the last memory write - uint.  spv::Id var_main_memexport_data_written_;  // If memory export is disabled in certain invocations or (if emulating some  // primitive types without a geometry shader) at specific guest vertex loop  // iterations because the translated shader is executed multiple times for the  // same guest vertex or pixel, this contains whether memory export is allowed  // in the current execution of the translated code.  // bool.  spv::Id main_memexport_allowed_;  // VS only - float3 (special exports).  spv::Id var_main_point_size_edge_flag_kill_vertex_;  // PS, only when needed - bool.
‎src/xenia/gpu/spirv_shader_translator_alu.ccCopy file name to clipboardexpand all lines: src/xenia/gpu/spirv_shader_translator_alu.cc+30-21Original file line numberDiff line numberDiff line change@@ -39,10 +39,14 @@ spv::Id SpirvShaderTranslator::ZeroIfAnyOperandIsZero(spv::Id value,      const_float_vectors_0_[num_components - 1], value);}void SpirvShaderTranslator::KillPixel(spv::Id condition) {void SpirvShaderTranslator::KillPixel(    spv::Id condition, uint8_t memexport_eM_potentially_written_before) {  SpirvBuilder::IfBuilder kill_if(condition, spv::SelectionControlMaskNone,                                  *builder_);  {    // Perform outstanding memory exports before the invocation becomes inactive    // and storage writes are disabled.    ExportToMemory(memexport_eM_potentially_written_before);    if (var_main_kill_pixel_ != spv::NoResult) {      builder_->createStore(builder_->makeBoolConstant(true),                            var_main_kill_pixel_);@@ -77,12 +81,12 @@ void SpirvShaderTranslator::ProcessAluInstruction(  // Whether the instruction has changed the predicate, and it needs to be  // checked again later.  bool predicate_written_vector = false;  spv::Id vector_result =      ProcessVectorAluOperation(instr, predicate_written_vector);  spv::Id vector_result = ProcessVectorAluOperation(      instr, memexport_eM_potentially_written_before, predicate_written_vector);  bool predicate_written_scalar = false;  spv::Id scalar_result =      ProcessScalarAluOperation(instr, predicate_written_scalar);  spv::Id scalar_result = ProcessScalarAluOperation(      instr, memexport_eM_potentially_written_before, predicate_written_scalar);  if (scalar_result != spv::NoResult) {    EnsureBuildPointAvailable();    builder_->createStore(scalar_result, var_main_previous_scalar_);@@ -106,7 +110,8 @@ void SpirvShaderTranslator::ProcessAluInstruction(}spv::Id SpirvShaderTranslator::ProcessVectorAluOperation(    const ParsedAluInstruction& instr, bool& predicate_written) {    const ParsedAluInstruction& instr,    uint8_t memexport_eM_potentially_written_before, bool& predicate_written) {  predicate_written = false;  uint32_t used_result_components =@@ -769,14 +774,16 @@ spv::Id SpirvShaderTranslator::ProcessVectorAluOperation(    case ucode::AluVectorOpcode::kKillGt:    case ucode::AluVectorOpcode::kKillGe:    case ucode::AluVectorOpcode::kKillNe: {      KillPixel(builder_->createUnaryOp(          spv::OpAny, type_bool_,          builder_->createBinOp(              spv::Op(kOps[size_t(instr.vector_opcode)]), type_bool4_,              GetOperandComponents(operand_storage[0], instr.vector_operands[0],                                   0b1111),              GetOperandComponents(operand_storage[1], instr.vector_operands[1],                                   0b1111))));      KillPixel(          builder_->createUnaryOp(              spv::OpAny, type_bool_,              builder_->createBinOp(                  spv::Op(kOps[size_t(instr.vector_opcode)]), type_bool4_,                  GetOperandComponents(operand_storage[0],                                       instr.vector_operands[0], 0b1111),                  GetOperandComponents(operand_storage[1],                                       instr.vector_operands[1], 0b1111))),          memexport_eM_potentially_written_before);      return const_float_0_;    }@@ -862,7 +869,8 @@ spv::Id SpirvShaderTranslator::ProcessVectorAluOperation(}spv::Id SpirvShaderTranslator::ProcessScalarAluOperation(    const ParsedAluInstruction& instr, bool& predicate_written) {    const ParsedAluInstruction& instr,    uint8_t memexport_eM_potentially_written_before, bool& predicate_written) {  predicate_written = false;  spv::Id operand_storage[2] = {};@@ -1257,12 +1265,13 @@ spv::Id SpirvShaderTranslator::ProcessScalarAluOperation(    case ucode::AluScalarOpcode::kKillsNe:    case ucode::AluScalarOpcode::kKillsOne: {      KillPixel(builder_->createBinOp(          spv::Op(kOps[size_t(instr.scalar_opcode)]), type_bool_,          GetOperandComponents(operand_storage[0], instr.scalar_operands[0],                               0b0001),          instr.scalar_opcode == ucode::AluScalarOpcode::kKillsOne              ? const_float_1_              : const_float_0_));                    spv::Op(kOps[size_t(instr.scalar_opcode)]), type_bool_,                    GetOperandComponents(operand_storage[0],                                         instr.scalar_operands[0], 0b0001),                    instr.scalar_opcode == ucode::AluScalarOpcode::kKillsOne                        ? const_float_1_                        : const_float_0_),                memexport_eM_potentially_written_before);      return const_float_0_;    }
‎src/xenia/gpu/spirv_shader_translator_memexport.ccCopy file name to clipboardexpand all lines: src/xenia/gpu/spirv_shader_translator_memexport.cc+950 Load DiffLarge diffs are not rendered by default.
‎src/xenia/gpu/vulkan/vulkan_command_processor.ccCopy file name to clipboardexpand all lines: src/xenia/gpu/vulkan/vulkan_command_processor.cc+56-8Original file line numberDiff line numberDiff line change@@ -2165,14 +2165,26 @@ bool VulkanCommandProcessor::IssueDraw(xenos::PrimitiveType prim_type,    return IssueCopy();  }  const ui::vulkan::VulkanProvider::DeviceInfo& device_info =      GetVulkanProvider().device_info();  memexport_ranges_.clear();  // Vertex shader analysis.  auto vertex_shader = static_cast<VulkanShader*>(active_vertex_shader());  if (!vertex_shader) {    // Always need a vertex shader.    return false;  }  pipeline_cache_->AnalyzeShaderUcode(*vertex_shader);  bool memexport_used_vertex = vertex_shader->memexport_eM_written() != 0;  // TODO(Triang3l): If the shader uses memory export, but  // vertexPipelineStoresAndAtomics is not supported, convert the vertex shader  // to a compute shader and dispatch it after the draw if the draw doesn't use  // tessellation.  if (vertex_shader->memexport_eM_written() != 0 &&      device_info.vertexPipelineStoresAndAtomics) {    draw_util::AddMemExportRanges(regs, *vertex_shader, memexport_ranges_);  }  // Pixel shader analysis.  bool primitive_polygonal = draw_util::IsPrimitivePolygonal(regs);@@ -2195,12 +2207,15 @@ bool VulkanCommandProcessor::IssueDraw(xenos::PrimitiveType prim_type,  } else {    // Disabling pixel shader for this case is also required by the pipeline    // cache.    if (!memexport_used_vertex) {    if (memexport_ranges_.empty()) {      // This draw has no effect.      return true;    }  }  // TODO(Triang3l): Memory export.  if (pixel_shader && pixel_shader->memexport_eM_written() != 0 &&      device_info.fragmentStoresAndAtomics) {    draw_util::AddMemExportRanges(regs, *pixel_shader, memexport_ranges_);  }  uint32_t ps_param_gen_pos = UINT32_MAX;  uint32_t interpolator_mask =@@ -2416,9 +2431,6 @@ bool VulkanCommandProcessor::IssueDraw(xenos::PrimitiveType prim_type,    current_guest_graphics_pipeline_layout_ = pipeline_layout;  }  const ui::vulkan::VulkanProvider::DeviceInfo& device_info =      GetVulkanProvider().device_info();  bool host_render_targets_used = render_target_cache_->GetPath() ==                                  RenderTargetCache::Path::kHostRenderTargets;@@ -2520,9 +2532,39 @@ bool VulkanCommandProcessor::IssueDraw(xenos::PrimitiveType prim_type,                                                  << (vfetch_index & 63);  }  // Synchronize the memory pages backing memory scatter export streams, and  // calculate the range that includes the streams for the buffer barrier.  uint32_t memexport_extent_start = UINT32_MAX, memexport_extent_end = 0;  for (const draw_util::MemExportRange& memexport_range : memexport_ranges_) {    uint32_t memexport_range_base_bytes = memexport_range.base_address_dwords                                          << 2;    if (!shared_memory_->RequestRange(memexport_range_base_bytes,                                      memexport_range.size_bytes)) {      XELOGE(          "Failed to request memexport stream at 0x{:08X} (size {}) in the "          "shared memory",          memexport_range_base_bytes, memexport_range.size_bytes);      return false;    }    memexport_extent_start =        std::min(memexport_extent_start, memexport_range_base_bytes);    memexport_extent_end =        std::max(memexport_extent_end,                 memexport_range_base_bytes + memexport_range.size_bytes);  }  // Insert the shared memory barrier if needed.  // TODO(Triang3l): Memory export.  shared_memory_->Use(VulkanSharedMemory::Usage::kRead);  // TODO(Triang3l): Find some PM4 command that can be used for indication of  // when memexports should be awaited instead of inserting the barrier in Use  // every time if memory export was done in the previous draw?  if (memexport_extent_start < memexport_extent_end) {    shared_memory_->Use(        VulkanSharedMemory::Usage::kGuestDrawReadWrite,        std::make_pair(memexport_extent_start,                       memexport_extent_end - memexport_extent_start));  } else {    shared_memory_->Use(VulkanSharedMemory::Usage::kRead);  }  // After all commands that may dispatch, copy or insert barriers, submit the  // barriers (may end the render pass), and (re)enter the render pass before@@ -2567,6 +2609,12 @@ bool VulkanCommandProcessor::IssueDraw(xenos::PrimitiveType prim_type,        primitive_processing_result.host_draw_vertex_count, 1, 0, 0, 0);  }  // Invalidate textures in memexported memory and watch for changes.  for (const draw_util::MemExportRange& memexport_range : memexport_ranges_) {    shared_memory_->RangeWrittenByGpu(memexport_range.base_address_dwords << 2,                                      memexport_range.size_bytes, false);  }  return true;}
‎src/xenia/gpu/vulkan/vulkan_command_processor.hCopy file name to clipboardexpand all lines: src/xenia/gpu/vulkan/vulkan_command_processor.h+3Original file line numberDiff line numberDiff line change@@ -737,6 +737,9 @@ class VulkanCommandProcessor : public CommandProcessor {  // System shader constants.  SpirvShaderTranslator::SystemConstants system_constants_;  // Temporary storage for memexport stream constants used in the draw.  std::vector<draw_util::MemExportRange> memexport_ranges_;};}  // namespace vulkan
